<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Thesis topics</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 18px;
      line-height: 1.45;
    }
    h1 { margin: 0 0 8px 0; font-size: 26px; }
    .intro {
      color: #333;
      max-width: 980px;
      margin-bottom: 14px;
    }
    .intro .meta {
      color: #666;
      margin-top: 6px;
    }
    table { border-collapse: collapse; width: 100%; }
    th, td {
      border: 1px solid #ddd;
      padding: 8px 10px;
      text-align: left;
      vertical-align: top;
    }
    th { background: #f5f5f5; position: sticky; top: 0; }
    .meta { color: #666; margin: 8px 0 10px 0; }
  </style>
</head>
<body>

  <h1>MSc thesis topic suggestions</h1>

  <div class="intro">
    These are master’s thesis topic suggestions proposed by Geoinformatics staff in the Department of Geosciences and Geography at the University of Helsinki.
    Currently, there are <span id="topicCount">…</span> available topics. If any of them interest you, if you’d like to discuss details, or if you want to propose your own topic, feel free to reach out to the responsible supervisor(s).
    The table will be updated regularly.
    <div class="meta" id="lastUpdated"></div>
  </div>

  <div class="meta" id="meta">Loading…</div>

  <div style="overflow:auto; max-height:80vh;">
    <table id="table"></table>
  </div>

  <script>
    const CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vRNi_gEvu9KIfyk1m2otEz0V9SBbsJZXSBw_q6u0MOTncXOwTsmIQf1DaLJz9zKbhZpR5z7hP4xJNni/pub?output=csv";

    const GVIZ_META_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vRNi_gEvu9KIfyk1m2otEz0V9SBbsJZXSBw_q6u0MOTncXOwTsmIQf1DaLJz9zKbhZpR5z7hP4xJNni/gviz/tq?tqx=out:json";

    const metaEl = document.getElementById("meta");
    const tableEl = document.getElementById("table");
    const topicCountEl = document.getElementById("topicCount");
    const lastUpdatedEl = document.getElementById("lastUpdated");

    const DESIRED_HEADERS = ["Topic", "Descritption", "Supervisor", "Email", "Date added"];

    function extractUpdatedTimeFromGviz(text) {
      const match = text.match(/"lastModified"\s*:\s*"([^"]+)"/);
      if (!match) return null;
      const d = new Date(match[1]);
      return isNaN(d.getTime()) ? null : d;
    }

    function parseCSV(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];

        if (inQuotes) {
          if (ch === '"' && next === '"') { cur += '"'; i++; continue; }
          if (ch === '"') { inQuotes = false; continue; }
          cur += ch;
          continue;
        }

        if (ch === '"') { inQuotes = true; continue; }

        if (ch === ",") {
          row.push(cur);
          cur = "";
          continue;
        }

        if (ch === "\r") continue;

        if (ch === "\n") {
          row.push(cur);
          rows.push(row);
          row = [];
          cur = "";
          continue;
        }

        cur += ch;
      }

      row.push(cur);
      rows.push(row);

      if (rows.length && rows[rows.length - 1].length === 1 && rows[rows.length - 1][0] === "") {
        rows.pop();
      }

      return rows;
    }

    function normalizeHeader(h) {
      return (h || "").trim().toLowerCase();
    }

    function renderTable(headers, dataRows, headerIndexMap) {
      tableEl.innerHTML = "";

      const thead = document.createElement("thead");
      const trh = document.createElement("tr");

      const thIdx = document.createElement("th");
      thIdx.textContent = "#";
      trh.appendChild(thIdx);

      headers.forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        trh.appendChild(th);
      });

      thead.appendChild(trh);
      tableEl.appendChild(thead);

      const tbody = document.createElement("tbody");
      dataRows.forEach((r, i) => {
        const tr = document.createElement("tr");

        const tdIdx = document.createElement("td");
        tdIdx.textContent = String(i + 1);
        tr.appendChild(tdIdx);

        headers.forEach(h => {
          const td = document.createElement("td");
          const idx = headerIndexMap[h];
          td.textContent = (idx !== undefined ? (r[idx] ?? "") : "").toString();

          if (h === "Email") {
            const email = td.textContent.trim();
            if (email && email.includes("@") && !email.includes(" ")) {
              td.innerHTML = "";
              const a = document.createElement("a");
              a.href = `mailto:${email}`;
              a.textContent = email;
              td.appendChild(a);
            }
          }

          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });

      tableEl.appendChild(tbody);
    }

    async function load() {
      try {
        fetch(GVIZ_META_URL)
          .then(r => r.text())
          .then(t => {
            const d = extractUpdatedTimeFromGviz(t);
            if (d) {
              lastUpdatedEl.textContent =
                `Last updated: ${d.toLocaleDateString()} ${d.toLocaleTimeString()}`;
            }
          })
          .catch(() => {});

        metaEl.textContent = "Loading…";
        const res = await fetch(CSV_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
        const csv = await res.text();

        const rows = parseCSV(csv);
        if (!rows.length) throw new Error("CSV was empty.");

        const sheetHeaders = rows[0].map(h => (h || "").trim());
        const dataRowsAll = rows.slice(1);

        const normToIndex = {};
        sheetHeaders.forEach((h, i) => { normToIndex[normalizeHeader(h)] = i; });

        const headerIndexMap = {};
        DESIRED_HEADERS.forEach(h => {
          headerIndexMap[h] = normToIndex[normalizeHeader(h)];
        });

        const dataRows = dataRowsAll.filter(r =>
          r.some(v => (v ?? "").toString().trim() !== "")
        );

        topicCountEl.textContent = String(dataRows.length);
        renderTable(DESIRED_HEADERS, dataRows, headerIndexMap);
        metaEl.textContent = `${dataRows.length} topics`;
      } catch (e) {
        metaEl.textContent = "Failed to load the table";
        topicCountEl.textContent = "0";
        console.error(e);
      }
    }

    load();
  </script>

</body>
</html>
