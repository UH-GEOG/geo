<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Thesis topics</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      line-height: 1.45;
      background: #fff;
      color: #111;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px;
    }

    h1 {
      margin: 0 0 8px 0;
      font-size: 26px;
    }

    .intro {
      color: #333;
      margin-bottom: 14px;
    }

    .intro .meta {
      color: #666;
      margin-top: 8px;
      font-size: 14px;
    }

    .status {
      color: #666;
      margin: 8px 0 10px 0;
      font-size: 14px;
    }

    .table-wrap {
      overflow: auto;
      max-height: 75vh;
      border: 1px solid #eee;
      border-radius: 10px;
    }

    table { border-collapse: collapse; width: 100%; min-width: 900px; }
    th, td {
      border-bottom: 1px solid #eee;
      padding: 10px 12px;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #fafafa;
      position: sticky;
      top: 0;
      border-bottom: 1px solid #e6e6e6;
    }
    tr:hover td { background: #fcfcfc; }
    a { color: inherit; }
  </style>
</head>
<body>
  <div class="container">
    <h1>MSc thesis topic suggestions</h1>

    <div class="intro">
      These are master’s thesis topic suggestions proposed by Geoinformatics staff in the Department of Geosciences and Geography at the University of Helsinki.
      Currently, there are <span id="topicCount">…</span> available topics. If any of them interest you, if you’d like to discuss details, or if you want to propose your own topic, feel free to reach out to the responsible supervisor(s).
      The table will be updated regularly.
      <div class="meta" id="lastUpdated"></div>
    </div>

    <div class="status" id="status">Loading…</div>

    <div class="table-wrap">
      <table id="table"></table>
    </div>
  </div>

  <script>
    const CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vRNi_gEvu9KIfyk1m2otEz0V9SBbsJZXSBw_q6u0MOTncXOwTsmIQf1DaLJz9zKbhZpR5z7hP4xJNni/pub?output=csv";

    const statusEl = document.getElementById("status");
    const tableEl = document.getElementById("table");
    const topicCountEl = document.getElementById("topicCount");
    const lastUpdatedEl = document.getElementById("lastUpdated");

    const DESIRED_HEADERS = ["Topic", "Descritption", "Supervisor", "Email", "Date added"];

    function parseCSV(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];

        if (inQuotes) {
          if (ch === '"' && next === '"') { cur += '"'; i++; continue; }
          if (ch === '"') { inQuotes = false; continue; }
          cur += ch;
          continue;
        }

        if (ch === '"') { inQuotes = true; continue; }

        if (ch === ",") { row.push(cur); cur = ""; continue; }
        if (ch === "\r") continue;

        if (ch === "\n") {
          row.push(cur);
          rows.push(row);
          row = [];
          cur = "";
          continue;
        }

        cur += ch;
      }

      row.push(cur);
      rows.push(row);

      if (rows.length && rows[rows.length - 1].length === 1 && rows[rows.length - 1][0] === "") {
        rows.pop();
      }

      return rows;
    }

    function normalizeHeader(h) {
      return (h || "").trim().toLowerCase();
    }

    function renderTable(headers, dataRows, headerIndexMap) {
      tableEl.innerHTML = "";

      const thead = document.createElement("thead");
      const trh = document.createElement("tr");

      const thIdx = document.createElement("th");
      thIdx.textContent = "#";
      trh.appendChild(thIdx);

      headers.forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        trh.appendChild(th);
      });

      thead.appendChild(trh);
      tableEl.appendChild(thead);

      const tbody = document.createElement("tbody");
      dataRows.forEach((r, i) => {
        const tr = document.createElement("tr");

        const tdIdx = document.createElement("td");
        tdIdx.textContent = String(i + 1);
        tr.appendChild(tdIdx);

        headers.forEach(h => {
          const td = document.createElement("td");
          const idx = headerIndexMap[h];
          td.textContent = (idx !== undefined ? (r[idx] ?? "") : "").toString();

          if (h === "Email") {
            const email = td.textContent.trim();
            if (email && email.includes("@") && !email.includes(" ")) {
              td.innerHTML = "";
              const a = document.createElement("a");
              a.href = `mailto:${email}`;
              a.textContent = email;
              td.appendChild(a);
            }
          }

          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });

      tableEl.appendChild(tbody);
    }

    async function load() {
      try {
        statusEl.textContent = "Loading…";

        const res = await fetch(CSV_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);

        // Try to use server-provided last modified timestamp
        const lastMod = res.headers.get("last-modified");
        if (lastMod) {
          const d = new Date(lastMod);
          if (!isNaN(d.getTime())) {
            lastUpdatedEl.textContent =
              `Last updated: ${d.toLocaleDateString()} ${d.toLocaleTimeString()}`;
          }
        } else {
          // Fallback: at least show when the page fetched it
          const d = new Date();
          lastUpdatedEl.textContent =
            `Last fetched: ${d.toLocaleDateString()} ${d.toLocaleTimeString()}`;
        }

        const csv = await res.text();
        const rows = parseCSV(csv);
        if (!rows.length) throw new Error("CSV was empty.");

        const sheetHeaders = rows[0].map(h => (h || "").trim());
        const dataRowsAll = rows.slice(1);

        const normToIndex = {};
        sheetHeaders.forEach((h, i) => { normToIndex[normalizeHeader(h)] = i; });

        const headerIndexMap = {};
        DESIRED_HEADERS.forEach(h => {
          headerIndexMap[h] = normToIndex[normalizeHeader(h)];
        });

        const dataRows = dataRowsAll.filter(r =>
          r.some(v => (v ?? "").toString().trim() !== "")
        );

        topicCountEl.textContent = String(dataRows.length);
        renderTable(DESIRED_HEADERS, dataRows, headerIndexMap);
        statusEl.textContent = `${dataRows.length} topics`;
      } catch (e) {
        statusEl.textContent = "Failed to load the table";
        topicCountEl.textContent = "0";
        console.error(e);
      }
    }

    load();
  </script>
</body>
</html>
